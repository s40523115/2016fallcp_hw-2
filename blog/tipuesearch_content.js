var tipuesearch = {"pages":[{"title":"W17 繪圖","url":"./w17-hui-tu.html","text":"window.onload=function(){ brython(1); } from browser import document from browser import window from browser import timer import math canvas = document[\"onebar\"] ctx = canvas.getContext(\"2d\") # 畫圓函式 def circle(x,y,r): ctx.beginPath() ctx.arc(x, y, r, 0, math.pi*2, True) ctx.fill() ctx.closePath() # 以下可以利用 ctx 物件進行畫圖 # 先畫一條直線 ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 # 將畫筆移動到 (200, 200) 座標點 ctx.moveTo(200, 200) # 然後畫直線到 (200, 300) 座標點 ctx.lineTo(200, 300) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" # 實際執行畫線 ctx.stroke() ctx.closePath() circle(200, 200, 5)","tags":"Course"},{"title":"Brython Canvas 繪圖","url":"./brython-canvas-hui-tu.html","text":"Brython Canvas 源自 Canvas API , 以下將介紹 Brython 的繪圖對應 API 使用方法. html5 Canvas cheat sheet Canvas tutorial Canvas demos window.onload=function(){ brython(1); } from browser import document from browser import html canvas = document[\"can1\"] ctx = canvas.getContext(\"2d\") def greensquare(ev): ctx.fillStyle = \"green\" ctx.fillRect(10, 10, 100, 100) def whitesquare(ev): ctx.fillStyle = \"white\" ctx.fillRect(10, 10, 100, 100) document[\"but1\"].bind(\"click\", greensquare) document[\"but2\"].bind(\"click\", whitesquare) 畫綠色矩型 清除 from browser import document from browser import html canvas = document[\"can1\"] ctx = canvas.getContext(\"2d\") def greensquare(ev): ctx.fillStyle = \"green\" ctx.fillRect(10, 10, 100, 100) def whitesquare(ev): ctx.fillStyle = \"white\" ctx.fillRect(10, 10, 100, 100) document[\"but1\"].bind(\"click\", greensquare) document[\"but2\"].bind(\"click\", whitesquare) 畫綠色矩型 清除 以下為基本動畫 ( 程式來源 ): from browser import document from browser import html from browser import alert from browser import timer # 數列內容為圖檔的 URL 連結字串 listImages = [ \"https://nodebox.net/code/data/media/growing_things.jpg\", \"https://nodebox.net/code/data/media/neongolden.jpg\" ] # 以下3個變數, 其資料型別為 dictionary dictImages = {} dictRot = {} dictAnim = {} # anim 為動態繪圖對應變數 anim = None def createIMG(id,src): i = 0 for i in range(len(listImages)): dictImages[i] = html.IMG(src=\"%s\"%listImages[i], id=i, alt=\"Nodebox 圖檔\") dictImages[i].onclick = info dictImages[i].onmouseover = rotateImage dictRot[i] = 0 dictAnim[i] = False def rotateImage(e): e.target.style.cursor = 'pointer' target = int(e.target.id) dictRot[target] += 45 dictAnim[target] = True rot = dictRot[target] e.target.style.webkitTransform = \"rotate(%sdeg)\"%rot def info(e): # 利用 alert() 顯示滑鼠點選 target 的 alt 資料 alert(e.target.alt) lenList = len(listImages) for i in range(lenList): createIMG(i,listImages[i]) def startAnimation(): global dictRot dictRot[0] += 3 rot = dictRot[0] dictImages[0].style.webkitTransform = \"rotate(%sdeg)\"%rot dictImages[1].style.webkitTransform = \"rotate(%sdeg)\"%-rot def launchAnimation(ev): global anim # 初始旋轉, anim 為 None if anim is None: anim = timer.set_interval(startAnimation, 30) # 初始旋轉後, 按鈕文字轉為\"暫停旋轉\" document['but3'].text = '暫停旋轉' elif anim == 'hold': # 當 anim 為 'hold' 表示曾經暫停後的旋轉, 因此持續以 set_interval() 持續旋轉, 且將 but3 文字轉為\"暫停旋轉\" anim = timer.set_interval(startAnimation, 30) document['but3'].text = '暫停旋轉' else: # 初始旋轉後, 使用者再按 but3, 此時 anim 非 None 也不是 'hold', 因此會執行 clear_interval() 暫停旋轉 # 且將 anim 變數設為 'hold', 且 but3 文字轉為\"繼續旋轉\" timer.clear_interval(anim) anim = 'hold' document['but3'].text = '繼續旋轉' for i in range(lenList): document[\"content\"] <= dictImages[i] document[\"but3\"].bind(\"click\", launchAnimation) 旋轉圖檔 四連桿模擬: from browser import document from browser import html from browser import timer import math class Coord(object): def __init__(self,x,y): self.x = x self.y = y def __sub__(self,other): # This allows you to substract vectors return Coord(self.x-other.x,self.y-other.y) def __repr__(self): # Used to get human readable coordinates when printing return \"Coord(%f,%f)\"%(self.x,self.y) def length(self): # Returns the length of the vector return math.sqrt(self.x**2 + self.y**2) def angle(self): # Returns the vector's angle return math.atan2(self.y,self.x) def normalize(coord): return Coord( coord.x/coord.length(), coord.y/coord.length() ) def perpendicular(coord): # Shifts the angle by pi/2 and calculate the coordinates # using the original vector length return Coord( coord.length()*math.cos(coord.angle()+math.pi/2), coord.length()*math.sin(coord.angle()+math.pi/2) ) # 點類別 class Point(object): # 起始方法 def __init__(self, x, y): self.x = x self.y = y # 繪製方法 def drawMe(self, g, r): self.g = g self.r = r self.g.save() self.g.moveTo(self.x,self.y) self.g.beginPath() # 根據 r 半徑繪製一個圓代表點的所在位置 self.g.arc(self.x, self.y, self.r, 0, 2*math.pi, True) self.g.moveTo(self.x,self.y) self.g.lineTo(self.x+self.r, self.y) self.g.moveTo(self.x, self.y) self.g.lineTo(self.x-self.r, self.y) self.g.moveTo(self.x, self.y) self.g.lineTo(self.x, self.y+self.r) self.g.moveTo(self.x, self.y) self.g.lineTo(self.x, self.y-self.r) self.g.stroke() self.g.restore() # 加入 Eq 方法 def Eq(self, pt): self.x = pt.x self.y = pt.y # 加入 setPoint 方法 def setPoint(self, px, py): self.x = px self.y = py # 加上 distance(pt) 方法, 計算點到 pt 的距離 def distance(self, pt): self.pt = pt x = self.x - self.pt.x y = self.y - self.pt.y return math.sqrt(x * x + y * y) # 利用文字標示點的座標位置 def tag(self, g): self.g = g self.g.beginPath() self.g.fillText(\"%d, %d\"%(self.x, self.y),self.x, self.y) self.g.stroke() # Line 類別物件 class Line(object): # 起始方法 def __init__(self, p1, p2): self.p1 = p1 self.p2 = p2 # 直線的第一點, 設為線尾 self.Tail = self.p1 # 直線組成的第二點, 設為線頭 self.Head = self.p2 # 直線的長度屬性 self.length = math.sqrt(math.pow(self.p2.x-self.p1.x, 2)+math.pow(self.p2.y-self.p1.y,2)) # setPP 以指定頭尾座標點來定義直線 def setPP(self, p1, p2): self.p1 = p1 self.p2 = p2 self.Tail = self.p1 self.Head = self.p2 self.length = math.sqrt(math.pow(self.p2.x-self.p1.x, 2)+math.pow(self.p2.y-self.p1.y,2)) # setRT 方法 for Line, 應該已經確定 Tail 點, 然後以 r, t 作為設定 Head 的參考 def setRT(self, r, t): self.r = r self.t = t x = self.r * math.cos(self.t) y = self.r * math.sin(self.t) self.Tail.Eq(self.p1) self.Head.setPoint(self.Tail.x + x,self.Tail.y + y) # getR 方法 for Line def getR(self): # x 分量與 y 分量 x = self.p1.x - self.p2.x y = self.p1.y - self.p2.y return math.sqrt(x * x + y * y) # 根據定義 atan2(y,x), 表示 (x,y) 與 正 x 軸之間的夾角, 介於 pi 與 -pi 間 def getT(self): x = self.p2.x - self.p1.x y = self.p2.y - self.p1.y if (math.fabs(x) < math.pow(10,-100)): if(y < 0.0): return (-math.pi/2) else: return (math.pi/2) else: return math.atan2(y, x) # setTail 方法 for Line def setTail(self, pt): self.pt = pt self.Tail.Eq(pt) self.Head.setPoint(self.pt.x + self.x, self.pt.y + self.y) # getHead 方法 for Line def getHead(self): return self.Head def getTail(self): return self.Tail def drawMe(self, g): self.g = g self.g.beginPath() self.g.moveTo(self.p1.x,self.p1.y) self.g.lineTo(self.p2.x,self.p2.y) self.g.stroke() def test(self): return (\"this is pure test to Inherit\") class Link(Line): def __init__(self, p1, p2): self.p1 = p1 self.p2 = p2 self.length = math.sqrt(math.pow((self.p2.x - self.p1.x), 2) + math.pow((self.p2.y - self.p1.y), 2)) #g context def drawMe(self, g): self.g = g hole = 5 radius = 10 length = self.getR() # alert(length) # 儲存先前的繪圖狀態 self.g.save() self.g.translate(self.p1.x,self.p1.y) #alert(str(self.p1.x)+\",\"+str(self.p1.y)) #self.g.rotate(-((math.pi/2)-self.getT())) self.g.rotate(-math.pi*0.5 + self.getT()) #alert(str(self.getT())) #self.g.rotate(10*math.pi/180) #this.g.rotate(-(Math.PI/2-this.getT())); # 必須配合畫在 y 軸上的 Link, 進行座標轉換, 也可以改為畫在 x 軸上... self.g.beginPath() self.g.moveTo(0,0) self.g.arc(0, 0, hole, 0, 2*math.pi, True) self.g.stroke() self.g.moveTo(0,length) self.g.beginPath() self.g.arc(0,length, hole, 0, 2*math.pi, True) self.g.stroke() self.g.moveTo(0,0) self.g.beginPath() self.g.arc(0,0, radius, 0, math.pi, True) self.g.moveTo(0+radius,0) self.g.lineTo(0+radius,0+length) self.g.stroke() self.g.moveTo(0,0+length) self.g.beginPath() self.g.arc(0, 0+length, radius, math.pi, 0, True) self.g.moveTo(0-radius,0+length) self.g.lineTo(0-radius,0) self.g.stroke() self.g.restore() self.g.beginPath() self.g.fillStyle = \"red\" self.g.font = \"bold 18px sans-serif\" self.g.fillText(\"%d, %d\"%(self.p2.x, self.p2.y),self.p2.x, self.p2.y) self.g.stroke() #self.g.restore() class Triangle(object): def __init__(self, p1, p2, p3): self.p1 = p1 self.p2 = p2 self.p3 = p3 def getLenp3(self): p1 = self.p1 ret = p1.distance(self.p2) return ret def getLenp1(self): p2 = self.p2 ret = p2.distance(self.p3) return ret def getLenp2(self): p1 = self.p1 ret = p1.distance(self.p3) return ret # 角度 def getAp1(self): ret = math.acos(((self.getLenp2() * self.getLenp2() + self.getLenp3() * self.getLenp3()) - self.getLenp1() * self.getLenp1()) / (2* self.getLenp2() * self.getLenp3())) return ret # def getAp2(self): ret =math.acos(((self.getLenp1() * self.getLenp1() + self.getLenp3() * self.getLenp3()) - self.getLenp2() * self.getLenp2()) / (2* self.getLenp1() * self.getLenp3())) return ret def getAp3(self): ret = math.acos(((self.getLenp1() * self.getLenp1() + self.getLenp2() * self.getLenp2()) - self.getLenp3() * self.getLenp3()) / (2* self.getLenp1() * self.getLenp2())) return ret def drawMe(self, g): self.g = g r = 5 # 繪出三個頂點 self.p1.drawMe(self.g,r) self.p2.drawMe(self.g,r) self.p3.drawMe(self.g,r) line1 = Line(self.p1,self.p2) line2 = Line(self.p1,self.p3) line3 = Line(self.p2,self.p3) # 繪出三邊線 line1.drawMe(self.g) line2.drawMe(self.g) line3.drawMe(self.g) # ends Triangle def # 透過三個邊長定義三角形 def setSSS(self, lenp3, lenp1, lenp2): self.lenp3 = lenp3 self.lenp1 = lenp1 self.lenp2 = lenp2 self.ap1 = math.acos(((self.lenp2 * self.lenp2 + self.lenp3 * self.lenp3) - self.lenp1 * self.lenp1) / (2* self.lenp2 * self.lenp3)) self.ap2 = math.acos(((self.lenp1 * self.lenp1 + self.lenp3 * self.lenp3) - self.lenp2 * self.lenp2) / (2* self.lenp1 * self.lenp3)) self.ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp2 * self.lenp2) - self.lenp3 * self.lenp3) / (2* self.lenp1 * self.lenp2)) # 透過兩個邊長與夾角定義三角形 def setSAS(self, lenp3, ap2, lenp1): self.lenp3 = lenp3 self.ap2 = ap2 self.lenp1 = lenp1 self.lenp2 = math.sqrt((self.lenp3 * self.lenp3 + self.lenp1 * self.lenp1) - 2* self.lenp3 * self.lenp1 * math.cos(self.ap2)) #等於 SSS(AB, BC, CA) def setSaSS(self, lenp2, lenp3, lenp1): self.lenp2 = lenp2 self.lenp3 = lenp3 self.lenp1 = lenp1 if(self.lenp1 > (self.lenp2 + self.lenp3)): #<CAB 夾角為 180 度, 三點共線且 A 介於 BC 之間 ret = math.pi else : # <CAB 夾角為 0, 三點共線且 A 不在 BC 之間 if((self.lenp1 < (self.lenp2 - self.lenp3)) or (self.lenp1 < (self.lenp3 - self.lenp2))): ret = 0.0 else : # 透過餘絃定理求出夾角 <CAB ret = math.acos(((self.lenp2 * self.lenp2 + self.lenp3 * self.lenp3) - self.lenp1 * self.lenp1) / (2 * self.lenp2 * self.lenp3)) return ret # 取得三角形的三個邊長值 def getSSS(self): temp = [] temp.append( self.getLenp1() ) temp.append( self.getLenp2() ) temp.append( self.getLenp3() ) return temp # 取得三角形的三個角度值 def getAAA(self): temp = [] temp.append( self.getAp1() ) temp.append( self.getAp2() ) temp.append( self.getAp3() ) return temp # 取得三角形的三個角度與三個邊長 def getASASAS(self): temp = [] temp.append(self.getAp1()) temp.append(self.getLenp1()) temp.append(self.getAp2()) temp.append(self.getLenp2()) temp.append(self.getAp3()) temp.append(self.getLenp3()) return temp #2P 2L return mid P def setPPSS(self, p1, p3, lenp1, lenp3): temp = [] self.p1 = p1 self.p3 = p3 self.lenp1 = lenp1 self.lenp3 = lenp3 #bp3 is the angle beside p3 point, cp3 is the angle for line23, p2 is the output line31 = Line(p3, p1) self.lenp2 = line31.getR() #self.lenp2 = self.p3.distance(self.p1) #這裡是求角3 ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp2 * self.lenp2) - self.lenp3 * self.lenp3) / (2 * self.lenp1 * self.lenp2)) #ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp3 * self.lenp3) - self.lenp2 * self.lenp2) / (2 * self.lenp1 * self.lenp3)) bp3 = line31.getT() cp3 = bp3 - ap3 temp.append(p3.x + self.lenp1*math.cos(cp3))#p2.x temp.append(p3.y + self.lenp1*math.sin(cp3))#p2.y return temp def tag(g, p): None midpt = Point(0, 0) tippt = Point(0, 0) contour = [] # 執行繪圖流程, 注意 x, y 為 global variables def draw(): global theta, midpt, oldpt, p2, p3 context.clearRect(0, 0, canvas.width, canvas.height) line1.drawMe(context) line2.drawMe(context) line3.drawMe(context) #triangle1.drawMe(context) #triangle2.drawMe(context) theta += dx p2.x = p1.x + line1.length*math.cos(theta*degree) p2.y = p1.y - line1.length*math.sin(theta*degree) # 找出一個 bug, 其中 link3_len 與 link2_len 輸入變數顛倒 # 但是動態繪圖應該還有 bugs p3.x, p3.y = triangle2.setPPSS(p2,p4,link3_len,link2_len) # 計算垂直單位向量 a = Coord(p3.x, p3.y) b = Coord(p2.x, p2.y) normal = perpendicular(perpendicular(normalize(a-b))) midpt.x = (p2.x + p3.x)/2 midpt.y = (p2.y + p3.y)/2 tippt.x = midpt.x - 375*normal.x tippt.y = midpt.y - 375*normal.y if theta < 360: contour.append((tippt.x, tippt.y)) context.beginPath() context.moveTo(midpt.x, midpt.y) context.lineTo(tippt.x, tippt.y) # 利用 fillRect 繪製一個長寬各 1 單位的正方形 for i in range(len(contour)): context.fillRect(contour[i][0], contour[i][1], 1, 1) context.stroke() p1.tag(context) # 以上為相關函式物件的定義區 # 全域變數 # 幾何位置輸入變數 x=10 y=10 r=10 # 畫布與繪圖內容 # 其他輸入變數 theta = 0 degree = math.pi/180.0 dx = 2 dy = 4 #set p1.p2.p3.p4 position p1 = Point(100,100) p2 = Point(200,100) p3 = Point(250,math.sqrt(250*250-50*50)+100) p4 = Point(300,100) #accord position create link line1 = Link(p1,p2) line2 = Link(p2,p3) line3 = Link(p3,p4) line4 = Link(p1,p4) line5 = Link(p2,p4) link2_len = p2.distance(p3) link3_len = p3.distance(p4) #link2_len = line1.getR() #link3_len = line3.getR() #alert(str(link2_len)+','+str(link3_len)) triangle1 = Triangle(p1,p2,p4) triangle2 = Triangle(p2,p3,p4) # 視窗載入時執行內容 # 繪圖畫布設定 canvas = document[\"fourbar\"] context = canvas.getContext(\"2d\") # 座標轉換, 移動 canvas.height 並且 y 座標變號, 也就是將原點座標移到畫面左下角 context.translate(0,canvas.height) context.scale(1,-1) #以間隔 10 micro seconds 重複呼叫 draw() timer.set_interval(draw,10)","tags":"Course"},{"title":"新年快樂","url":"./xin-nian-kuai-le.html","text":"2017 年元旦快樂 首先了解 random 亂數模組的用法 然後利用 random 模組產生一個介於 1-100 的整數, 列印在網頁上. window.onload=function(){ brython(1); } from browser import document from browser import html import random print_location = document[\"newyear\"] def gen_int(): num = random.randint(1, 49) # 設法將 num 列印在網頁上 #print_location = document[\"newyear\"] print_location <= num + html.BR() def lottery(e): for i in range(6): gen_int() print_location <= \"(可能重複)恭喜中獎!\" + html.BR() #document[\"but1\"].bind(\"click\", gen_int) document[\"but1\"].bind(\"click\", lottery) 產生 1-49 整數亂數 (可能重複) from browser import document from browser import html import random print_location = document[\"newyear\"] def gen_int(): num = random.randint(1, 49) # 設法將 num 列印在網頁上 #print_location = document[\"newyear\"] print_location <= num + html.BR() def lottery(e): for i in range(6): gen_int() print_location <= \"(可能重複)恭喜中獎!\" + html.BR() #document[\"but1\"].bind(\"click\", gen_int) document[\"but1\"].bind(\"click\", lottery) 產生 1-49 整數亂數 (可能重複) 因為上述程式可能會產生相同的號碼, 改用 random.sample() , 使其產生六個不同的整數!! from browser import document from browser import html import random print_location = document[\"newyear\"] def lottery(e): num_list = random.sample(list(range(1, 50)), 6) for i in range(6): print_location <= num_list[i] + html.BR() print_location <= \"(不會重複)恭喜中獎!\" + html.BR() document[\"but2\"].bind(\"click\", lottery) (不會重複)恭喜中獎 from browser import document from browser import html import random print_location = document[\"newyear\"] def lottery(e): num_list = random.sample(list(range(1, 50)), 6) for i in range(6): print_location <= num_list[i] + html.BR() print_location <= \"(不會重複)恭喜中獎!\" + html.BR() document[\"but2\"].bind(\"click\", lottery) 恭喜中獎 以下建立一個猜數字遊戲: from browser import document from browser import html import random id3 = document[\"id3\"] def guess(ev): # 清除 id3 中的內容 id3.clear() id3 <= \"開始玩猜數字遊戲\" + html.BR() 標準答案 = random.randint(1, 100) 你猜的數字 = int(input(\"請輸入您所猜 1~100 間的整數:\")) 猜測次數 = 1 while 標準答案 != 你猜的數字: if 標準答案 < 你猜的數字: #print(\"太大了，再猜一次 :)加油\") # 清除 id3 中的內容 id3.clear() id3 <= \"猜第\" + str(猜測次數) + \"次, 太大了，再猜一次 :)加油\" + html.BR() else: #print(\"太小了，再猜一次 :)加油\") # 清除 id3 中的內容 id3.clear() id3 <= \"猜第\" + str(猜測次數) + \"次, 太小了，再猜一次 :)加油\" + html.BR() 你猜的數字 = int(input(\"請輸入您所猜 1~100 間的整數:\")) 猜測次數 += 1 #print(\"猜對了！總共猜了\", 猜測次數, \"次\") id3 <= \"猜對了！答案為\" + str(標準答案) + \", 總共猜了\" + str(猜測次數) + \"次\" document[\"but3\"].bind(\"click\", guess) 玩猜數字遊戲 from browser import document from browser import html import random id3 = document[\"id3\"] def guess(ev): # 清除 id3 中的內容 id3.clear() id3 <= \"開始玩猜數字遊戲\" + html.BR() 標準答案 = random.randint(1, 100) 你猜的數字 = int(input(\"請輸入您所猜 1~100 間的整數:\")) 猜測次數 = 1 while 標準答案 != 你猜的數字: if 標準答案 < 你猜的數字: #print(\"太大了，再猜一次 :)加油\") # 清除 id3 中的內容 id3.clear() id3 <= \"猜第\" + str(猜測次數) + \"次, 太大了，再猜一次 :)加油\" + html.BR() else: #print(\"太小了，再猜一次 :)加油\") # 清除 id3 中的內容 id3.clear() id3 <= \"猜第\" + str(猜測次數) + \"次, 太小了，再猜一次 :)加油\" + html.BR() 你猜的數字 = int(input(\"請輸入您所猜 1~100 間的整數:\")) 猜測次數 += 1 #print(\"猜對了！總共猜了\", 猜測次數, \"次\") id3 <= \"猜對了！答案為\" + str(標準答案) + \", 總共猜了\" + str(猜測次數) + \"次\" document[\"but3\"].bind(\"click\", guess) 玩猜數字遊戲 以下則利用程式執行猜數字遊戲: 利用程式玩猜數字 from browser import document from browser import html import random id4 = document[\"id4\"] def autoguess(ev): 執行次數 = 100 總猜測次數 = 0 for i in range(執行次數): id4 <= \"第\" + str(i+1) + \"次玩:\" + html.BR() 下限 = 1 上限 = 100 標準答案 = random.randint(下限, 上限) pc猜的數字 = random.randint(下限, 上限) #print(標準答案, pc猜的數字) #integer int() #string str() #float float() #你猜的數字 = int(input(\"請輸入您所猜的整數:\")) 猜測次數 = 1 while 標準答案 != pc猜的數字: if 標準答案 < pc猜的數字: #print(\"太大了，再猜一次 :)加油\") # 因此已經確定\"pc猜的數字\"不是答案, 因此 - 1 id4 <= \"電腦猜的數字:\" + str(pc猜的數字) + \" 太大了!\" + html.BR() 上限 = pc猜的數字 - 1 else: #print(\"太小了，再猜一次 :)加油\") # 因此已經確定\"pc猜的數字\"不是答案, 因此 + 1 id4 <= \"電腦猜的數字:\" + str(pc猜的數字) + \" 太小了!\" + html.BR() 下限 = pc猜的數字 + 1 #pc猜的數字 = int(input(\"請輸入您所猜的整數:\")) pc猜的數字 = random.randint(下限, 上限) 猜測次數 += 1 #print(\"猜對了！總共猜了\", 猜測次數, \"次\") id4 <= \"電腦猜對了, 答案為: \" + str(標準答案) + \", 總共猜了 \"+ str(猜測次數) + \"次\" + html.BR() 總猜測次數 += 猜測次數 平均猜測次數 = int(總猜測次數/執行次數) #print(\"平均次數\", 平均猜測次數) id4 <= \"平均次數: \" + str(平均猜測次數) document[\"but4\"].bind(\"click\", autoguess) from browser import document from browser import html import random id4 = document[\"id4\"] def autoguess(ev): 執行次數 = 100 總猜測次數 = 0 for i in range(執行次數): id4 <= \"第\" + str(i+1) + \"次玩:\" + html.BR() 下限 = 1 上限 = 100 標準答案 = random.randint(下限, 上限) pc猜的數字 = random.randint(下限, 上限) #print(標準答案, pc猜的數字) #integer int() #string str() #float float() #你猜的數字 = int(input(\"請輸入您所猜的整數:\")) 猜測次數 = 1 while 標準答案 != pc猜的數字: if 標準答案 < pc猜的數字: #print(\"太大了，再猜一次 :)加油\") # 因此已經確定\"pc猜的數字\"不是答案, 因此 - 1 id4 <= \"電腦猜的數字:\" + str(pc猜的數字) + \" 太大了!\" + html.BR() 上限 = pc猜的數字 - 1 else: #print(\"太小了，再猜一次 :)加油\") # 因此已經確定\"pc猜的數字\"不是答案, 因此 + 1 id4 <= \"電腦猜的數字:\" + str(pc猜的數字) + \" 太小了!\" + html.BR() 下限 = pc猜的數字 + 1 #pc猜的數字 = int(input(\"請輸入您所猜的整數:\")) pc猜的數字 = random.randint(下限, 上限) 猜測次數 += 1 #print(\"猜對了！總共猜了\", 猜測次數, \"次\") id4 <= \"電腦猜對了, 答案為: \" + str(標準答案) + \", 總共猜了 \"+ str(猜測次數) + \"次\" + html.BR() 總猜測次數 += 猜測次數 平均猜測次數 = int(總猜測次數/執行次數) #print(\"平均次數\", 平均猜測次數) id4 <= \"平均次數: \" + str(平均猜測次數) document[\"but4\"].bind(\"click\", autoguess) 利用程式玩猜數字","tags":"Course"},{"title":"耶誕快樂","url":"./ye-dan-kuai-le.html","text":"耶誕快樂 window.onload=function(){ brython(1); } from browser import document as do from browser import html c = do[\"con\"] def compa(e): your_input = input(\"請輸入一個整數!\") # 如何判斷所輸入的整數比 10 大 try: if int(your_input) > 10: c <= \"所輸入的整數:\" + your_input + \"比 10 大\" + html.BR() else: c <= \"所輸入的整數:\" + your_input + \"比 10 小\" + html.BR() except: c <= \"請輸入整數!!\" + html.BR() #print(\"test\") ''' for i in range(5): c <= \"test\" + html.BR() ''' do[\"b1\"].bind(\"click\", compa) compa from browser import document as do from browser import html c = do[\"con\"] def compa(e): your_input = input(\"請輸入一個整數!\") # 如何判斷所輸入的整數比 10 大 try: if int(your_input) > 10: c <= \"所輸入的整數:\" + your_input + \"比 10 大\" + html.BR() else: c <= \"所輸入的整數:\" + your_input + \"比 10 小\" + html.BR() except: c <= \"請輸入整數!!\" + html.BR() #print(\"test\") ''' for i in range(5): c <= \"test\" + html.BR() ''' do[\"b1\"].bind(\"click\", compa) compa","tags":"Course"},{"title":"計算機程式 W14 範例整理","url":"./ji-suan-ji-cheng-shi-w14-fan-li-zheng-li.html","text":"本週的學習重點在導入 Leo Editor @clean 節點指令的用法, 利用子節點管理各章節的範例, 逐一將程式改寫為 Brython 格式後, 直接在瀏覽器中執行. 讓學員了解使用階層式架構管理資料的便利性. 以下為 http://mde.tw/2016fallcp/course/Python3Programs.txt 中的 ch01 綜合範例, 其餘範例位於本 Leo Editor 專案檔中的 \"Python3 程式範例\" 節點, 請各組一一將範例程式碼與執行結果, 放入各學員的課程網誌中. 本課程 W15 - W18 週將利用 introduction_to_prog_python3_2012.pdf 與 python_for_everybody_2015.pdf 中有關物件導向的說明, 並且配合 https://github.com/mdecourse/webgame 倉儲中的 Leo Editor 專案, 希望各組能夠了解利用 Python3 與 Brython 語法處理 靜態圖檔 、 動態圖檔 與 網際遊戲 的運作原理, 順利完成各組的期末報告. window.onload=function(){ brython(1); }","tags":"Course"},{"title":"計算機程式 W13","url":"./ji-suan-ji-cheng-shi-w13.html","text":"在機械設計工程系的計算機程式課程中, 學習 Python3 的基本目的, 希望在最短時間內, 讓學員能夠除了在身旁的電腦或筆電上, 利用 Python3 程式語法進行各種資料處理與運算外, 還希望學員能夠透過編寫網際程式, 利用網站執行協同設計程式. Python3 能做什麼? Python3 指的是 Python 程式語言第 3 版, 是一種解譯式泛用型程式語言, 能夠在程式碼編寫好了之後, 馬上利用 Python3 解譯器執行, 程式碼是在執行當下才自動轉為機器碼, 因此使用者可以最簡便的方式使用 Python3. 在大一的計算機課程中, 我們利用 Python 編寫的 Leo Editor 作為近端的資料管理與整合程式開發中心, 並利用 Python 編寫的 Pelican 工具, 將使用者建立的 Markdown 格式檔案, 轉為組成 Blog 系統所需要的 html 格式檔案. 使用者所編寫的 Markdown 檔案中可以嵌入格式與 Python3 相容的 Brython 程式碼, 也可以直接在瀏覽器中執行這些 Brython 程式, 進行網際環境中的資料處理與 2D/3D 靜態與動態繪圖. 因此, 在這門課程的範疇中, Python3 能夠做什麼? 簡單說, 我們在此所學習的 Python3 計算機程式語法, 可以在單機操作系統中, 以及瀏覽器中利用電腦進行資料處理、數值運算與繪圖. Python3 的資料處理 Leo Editor 利用大綱模式管理資料, 就是 Python3 程式應用的範例, 至於 Pelican 套件將 Markdown 檔案轉為 Blog 專用的 html 檔案, 也是一系列利用 Python3 指令與語法進行資料處理的過程. 課程進行初始, 本課程利用 Python3 程式進行學員資料的讀取、分組排序, 轉而利用 Brython 直接在網頁上處理學員資料, 也是 Python3 程式進行資料處理的應用之一. Python3 的數值運算 在工程應用中, 最簡單的數值運算就是各種工程尺寸與單位的換算, 在本課程中, 使用者可以利用 Python3 程式語法建立單機與網頁上執行的物理量單位換算程式. Python3 的繪圖 本課程中的 Python3 繪圖應用以在瀏覽器中執行為主, 使用者學會基本的 Brython 程式語法以及 html5 Canvas 繪圖指令後, 就可以直接將 Canvas 繪圖程式寫在 Markdown 檔案中, 然後再利用 Pelican 將檔案轉為 html Python 程式執行 由於本課程主要在 Windows 10 環境中, 以可攜的 Miniconda Python 3.5 系統為主, 使用者啟動後 ,可以利用可攜系統對應的命令列, 輸入 python 後帶出解譯器環境, 就可以直接下指令執行 Python3 程式語法. 此外, 若使用者將 Python3 程式存成 ex1.py, 也可以直接在可攜系統對應的命令列中, 透過 python ex1.py 執行 ex1.py 程式. 當然, 假如 ex1.py 已經利用 Leo Editor 的 @edit 節點指令導入, 也可以在 Leo Editor 環境中, 透過 Ctrl+b 按鍵執行, 而且假如要在 Leo Editor 的 Log 視窗中列印, 可以使用 g.es() 函式, 其中的 g 代表 Leo Editor 的 global 物件, 而 es() 函式則代表 echo string. 本課程 Brython 程式的執行則牽涉 3 個步驟, 也就是導入 brython.js, 啟動 brython, 最後才能 html5 的檔案中, 利用 script 標註執行 Brython 程式. 接下來我們將利用 Hello Mde 字串的列印進行示範. 操作系統中, 進入解譯環境列印: 操作系統中, 呼叫 python 執行 ex1.py 列印: Leo Editor 導入 ex1.py 當作節內容後, 按下 Ctrl+b 列印: Leo Editor 導入 ex1.py 後, 改用 g.es() 函式, 按下 Ctrl+b 列印: 在瀏覽器中以 alert() 函式列印: window.onload=function(){ brython(1); } from browser import document as doc from browser import alert def echo(ev): alert(\"Hello Mde\") doc['alert'].bind('click',echo) 呼叫 alert 列印! from browser import document as doc from browser import alert def echo(ev): alert(\"Hello Mde\") doc['alert'].bind('click',echo) 呼叫 alert 列印! 在瀏覽器中, 直接將執行結果嵌入 html 網頁中: from browser import document as doc # 特殊 html 標註必須透過 html 模組呼叫 # http://www.brython.info/static_doc/en/html.html #from browser import html container = doc[\"ex1\"] container <= \"Hello Mde\" from browser import document as doc # 特殊 html 標註必須透過 html 模組呼叫 # http://www.brython.info/static_doc/en/html.html #from browser import html container = doc[\"ex1\"] container <= \"Hello Mde\" Python3 的繪圖 from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"bat\"] ctx = canvas.getContext(\"2d\") # 開始畫圖 ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 # 利用 transform 將 y 座標反轉, 且 offset canvas.height # (X scale, X skew, Y skew, Y scale, X offset, Y offset) # 繪圖座標放大 5 倍, 並配合圖形位置進行座標轉換 ctx.transform(5, 0, 0, -5, canvas.width/2, canvas.height/2) bat_points = [(5, -1), (6, -2), (8, 0), (10, 4), (12, 8), (13, 12), (13, 16), (15, 15), (19, 15), (22, 15), (24, 15), (26, 16), (25, 14), (23, 10), (22, 6), (19, 5), (17, 3), (16, 1), (15, -3), (15, -7), (13, -8), (11, -10), (9, -12), (8, -14), (7, -18), (5, -16), (1, -14), (0, -14), (-4, -15), (-6, -17), (-8, -15), (-10, -13), (-11, -12), (-12, -12), (-13, -12), (-14, -13), (-17, -15), (-18, -15), (-22, -13), (-24, -12), (-25, -12), (- 27, -13), (-25, -11), (-23, -8), (-21, -5), (-19, 0), (-15, -2), (-12, -4), (-10, -5), (-7, -6), (-4, -6), (-1, -6), (-1, -3), (-2, 1), (0, -1), (1, 0), (2, 0), (3, 1), (3, 3), (5, -1)] ctx.moveTo(3, 3) for point in bat_points: ctx.lineTo(point[0],point[1]) ctx.stroke() ctx.closePath() from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"bat\"] ctx = canvas.getContext(\"2d\") # 開始畫圖 ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 # 利用 transform 將 y 座標反轉, 且 offset canvas.height # (X scale, X skew, Y skew, Y scale, X offset, Y offset) # 繪圖座標放大 5 倍, 並配合圖形位置進行座標轉換 ctx.transform(5, 0, 0, -5, canvas.width/2, canvas.height/2) bat_points = [(5, -1), (6, -2), (8, 0), (10, 4), (12, 8), (13, 12), (13, 16), (15, 15), (19, 15), (22, 15), (24, 15), (26, 16), (25, 14), (23, 10), (22, 6), (19, 5), (17, 3), (16, 1), (15, -3), (15, -7), (13, -8), (11, -10), (9, -12), (8, -14), (7, -18), (5, -16), (1, -14), (0, -14), (-4, -15), (-6, -17), (-8, -15), (-10, -13), (-11, -12), (-12, -12), (-13, -12), (-14, -13), (-17, -15), (-18, -15), (-22, -13), (-24, -12), (-25, -12), (- 27, -13), (-25, -11), (-23, -8), (-21, -5), (-19, 0), (-15, -2), (-12, -4), (-10, -5), (-7, -6), (-4, -6), (-1, -6), (-1, -3), (-2, 1), (0, -1), (1, 0), (2, 0), (3, 1), (3, 3), (5, -1)] ctx.moveTo(3, 3) for point in bat_points: ctx.lineTo(point[0],point[1]) ctx.stroke() ctx.closePath()","tags":"Course"},{"title":"W12 Brython 繪圖練習","url":"./w12-brython-hui-tu-lian-xi.html","text":"Brython 繪圖 繪圖流程, 導入程式庫, 啟動, 然後引用各種模組開始繪圖. 以下利用函式定義進行和弦底稿繪圖: window.onload=function(){ brython(1); } from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"chord1\"] ctx = canvas.getContext(\"2d\") def background(x, y, xinc, yinc, xnum, ynum, ctx): # 水平線 for i in range(ynum+1): ctx.beginPath() # 設定線的寬度為 1 個單位 if i == 0: ctx.lineWidth = 7 else: ctx.lineWidth = 1 ctx.moveTo(x-1, y+i*yinc) ctx.lineTo(x+xnum*xinc+1, y+i*yinc) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 垂直線 for i in range(xnum+1): ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 ctx.moveTo(x+i*xinc, y) ctx.lineTo(x+i*xinc, y+ynum*yinc) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() def canvasText(x, y, fontSize, string, sup, sub, color, ctx): # 標定各弦音符號, 以及把位編號 ctx.beginPath() ctx.fillStyle = color ctx.strokeStyle = color #ctx.font = \"20px Arial\" ctx.font = str(fontSize)+ \"px Arial\" ctx.fillText(string, x, y) ctx.font = str(fontSize-8)+ \"px Arial\" if sup != \"\": ctx.fillText(sup, x+fontSize/1.6, y-fontSize/2) if sub != \"\": ctx.fillText(sup, x+fontSize/1.6, y) ctx.fill() ctx.stroke() ctx.closePath() w = 20 h = 30 background(100, 100, w, h, 5, 5, ctx) mylist = [\"E\", \"A\", \"D\", \"G\", \"B\", \"E\"] num = 0 for s in mylist: #canvasText(100, 80, 20, \"A\", \"b\", \"\", \"black\", ctx) canvasText(100+num*w, 80, 20, s, \"\", \"\", \"black\", ctx) num = num + 1 上述繪圖的程式碼: window.onload=function(){ brython(1); } from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"chord1\"] ctx = canvas.getContext(\"2d\") def background(x, y, xinc, yinc, xnum, ynum, ctx): # 水平線 for i in range(ynum+1): ctx.beginPath() # 設定線的寬度為 1 個單位 if i == 0: ctx.lineWidth = 7 else: ctx.lineWidth = 1 ctx.moveTo(x-1, y+i*yinc) ctx.lineTo(x+xnum*xinc+1, y+i*yinc) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 垂直線 for i in range(xnum+1): ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 ctx.moveTo(x+i*xinc, y) ctx.lineTo(x+i*xinc, y+ynum*yinc) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() def canvasText(x, y, fontSize, string, sup, sub, color, ctx): # 標定各弦音符號, 以及把位編號 ctx.beginPath() ctx.fillStyle = color ctx.strokeStyle = color #ctx.font = \"20px Arial\" ctx.font = str(fontSize)+ \"px Arial\" ctx.fillText(string, x, y) ctx.font = str(fontSize-8)+ \"px Arial\" if sup != \"\": ctx.fillText(sup, x+fontSize/1.6, y-fontSize/2) if sub != \"\": ctx.fillText(sup, x+fontSize/1.6, y) ctx.fill() ctx.stroke() ctx.closePath() w = 20 h = 30 background(100, 100, w, h, 5, 5, ctx) canvasText(100, 80, 20, \"A\", \"b\", \"\", \"black\", ctx)","tags":"Course"},{"title":"W11 Brython 繪圖範例","url":"./w11-brython-hui-tu-fan-li.html","text":"Brython 繪圖 繪圖流程, 導入程式庫, 啟動, 然後引用各種模組開始繪圖 window.onload=function(){ brython(1); } from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"chord1\"] ctx = canvas.getContext(\"2d\") ''' # 改用 background 函式繪圖 # 水平線 for i in range(5): ctx.beginPath() # 設定線的寬度為 1 個單位 if i == 0: ctx.lineWidth = 7 else: ctx.lineWidth = 1 ctx.moveTo(99, 100+i*30) ctx.lineTo(201, 100+i*30) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 垂直線 for i in range(6): ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 ctx.moveTo(100+i*20, 100) ctx.lineTo(100+i*20, 220) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() ''' def canvasText(x, y, fontSize, string, sup, sub, color, ctx): # 標定各弦音符號, 以及把位編號 ctx.beginPath() ctx.fillStyle = color ctx.strokeStyle = color #ctx.font = \"20px Arial\" ctx.font = str(fontSize)+ \"px Arial\" ctx.fillText(string, x, y) ctx.font = str(fontSize-8)+ \"px Arial\" if sup != \"\": ctx.fillText(sup, x+fontSize/1.6, y-fontSize/2) if sub != \"\": ctx.fillText(sup, x+fontSize/1.6, y) ctx.fill() ctx.stroke() ctx.closePath() # 設法利用運算印出吉他各把位的音名 def doreme(x, y, fontSize, order, ctx): # EADGBE (guitar string) # FgGaAbBCdDeE (C=Do, D=Re, E=Mi) #簡譜 1 2 3 4 5 6 7 #音名 C D E F G A B #唱名 Do Re Mi Fa Sol La Ti # 讓音名數列可以每 12 音名後, 升高 key 後從頭開始 if order > 12: order = order % 12 if order == 1: canvasText(x, y, fontSize, \"A\", \"\", \"\", \"black\", ctx) elif order ==2: canvasText(x, y, fontSize, \"B\", \"b\", \"\", \"red\", ctx) elif order == 3: canvasText(x, y, fontSize, \"B\", \"\", \"\", \"black\", ctx) elif order == 4: canvasText(x, y, fontSize, \"C\", \"\", \"\", \"black\", ctx) elif order == 5: canvasText(x, y, fontSize, \"D\", \"b\", \"\", \"red\", ctx) elif order == 6: canvasText(x, y, fontSize, \"D\", \"\", \"\", \"black\", ctx) elif order == 7: canvasText(x, y, fontSize, \"E\", \"b\", \"\", \"red\", ctx) elif order == 8: canvasText(x, y, fontSize, \"E\", \"\", \"\", \"black\", ctx) elif order == 9: canvasText(x, y, fontSize, \"F\", \"\", \"\", \"black\", ctx) elif order == 10: canvasText(x, y, fontSize, \"G\", \"b\", \"\", \"red\", ctx) elif order == 11: canvasText(x, y, fontSize, \"G\", \"\", \"\", \"black\", ctx) elif order == 12: canvasText(x, y, fontSize, \"A\", \"b\", \"\", \"red\", ctx) else: canvasText(x, y, fontSize, \"Error\", \"\", \"\", \"red\", ctx) def background(x, y, xinc, yinc, xnum, ynum, ctx): # 水平線 for i in range(ynum+1): ctx.beginPath() # 設定線的寬度為 1 個單位 if i == 0: ctx.lineWidth = 7 else: ctx.lineWidth = 1 ctx.moveTo(x-1, y+i*yinc) ctx.lineTo(x+xnum*xinc+1, y+i*yinc) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 垂直線 for i in range(xnum+1): ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 ctx.moveTo(x+i*xinc, y) ctx.lineTo(x+i*xinc, y+ynum*yinc) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 標定各弦音符號, 以及把位編號 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.font = \"20px Arial\" sixString = [\"E\", \"A\", \"D\", \"G\", \"B\", \"E\"] stringNum = 0 for i in sixString: ctx.fillText(i, x-7+stringNum*xinc, y-30) stringNum = stringNum + 1 ctx.fill() ctx.stroke() ctx.closePath() # EADGBE (guitar string) # FgGaAbBCdDeE (C=Do, D=Re, E=Mi) canvasText(x, y-50, 20, \"A\", \"\", \"\", \"black\", ctx) canvasText(x+xinc, y-50, 20, \"B\", \"b\", \"\", \"red\", ctx) canvasText(x+xinc*2, y-50, 20, \"B\", \"\", \"\", \"black\", ctx) canvasText(x+xinc*3, y-50, 20, \"C\", \"\", \"\", \"black\", ctx) canvasText(x+xinc*4, y-50, 20, \"D\", \"b\", \"\", \"red\", ctx) canvasText(x+xinc*5, y-50, 20, \"D\", \"\", \"\", \"black\", ctx) canvasText(x+xinc*6, y-50, 20, \"E\", \"b\", \"\", \"red\", ctx) canvasText(x+xinc*7, y-50, 20, \"E\", \"\", \"\", \"black\", ctx) canvasText(x+xinc*8, y-50, 20, \"F\", \"\", \"\", \"black\", ctx) canvasText(x+xinc*9, y-50, 20, \"G\", \"b\", \"\", \"red\", ctx) canvasText(x+xinc*10, y-50, 20, \"G\", \"\", \"\", \"black\", ctx) canvasText(x+xinc*11, y-50, 20, \"A\", \"b\", \"\", \"red\", ctx) #################################### # 以下利用數列運算, 從已知第1把位的音名分別推算各把位的音名 # 吉他初始音名次序 816(11)38 #################################### firstBar = [8, 1, 6, 11, 3, 8] # j 為往下增量 for j in range(4): # k 為 往右把位初始值 fontSize = 15 for k in range(6): bx = x + (k)*w - fontSize/3 by = y + (j)*h+h/2 + fontSize/2 order = firstBar[k] + j + 1 doreme(bx, by, fontSize, order, ctx) # 一開始 x, y 為圓球圓心, 但是為了配合和弦繪圖 # 將 x, y 改為和弦的左上角座標 x, y # 配合 w, h, wcoord, hcoord 進行運算得到圓的圓心座標 bx, by #def ball(x, y, w, h , wcoord, hcoord, r, color, ctx): def ball(x, y, w, h , wcoord, hcoord, color, ctx): bx = x + (wcoord-1)*w by = y + (hcoord-1)*h+h/2 if w < h: r2 = w/2 -2 else: r2 = h/2 -2 ctx.beginPath() #ctx.fillStyle = 'black' ctx.fillStyle = color #ctx.strokeStyle = \"black\" ctx.strokeStyle = color #ctx.arc(50, 80, 9, 0, 2*math.pi, False) ctx.arc(bx, by, r2, 0, 2*math.pi, False) # 為了疊上各把位的音名, 暫時不填色 #ctx.fill() ctx.stroke() ctx.closePath() x = 300 y = 200 w = 20 h = 30 # 將前面的水平線與垂直線繪圖改用 background 繪圖 background(100, 100, w, h, 5, 4, ctx) background(x, y, w, h, 5, 4, ctx) #background(100, 300, 10, 10, 5, 4, ctx) #background(300, 100, 10, 10, 5, 12, ctx) # 配合 300, 300 的和絃背景, w=30, h=30, (1,1) 位置放入圓 for i in range( 6): for j in range(3): ball(x, y, w, h, i+1, j+1, 'black', ctx) ball(x, y, w, h, 1, 4, 'red', ctx) #ball(300, 300, 30, 20, 1, 1, 9, 'black', ctx) 上述繪圖第一部分使用迴圈繪製水平線與垂直線: from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"chord1\"] ctx = canvas.getContext(\"2d\") # 水平線 for i in range(5): ctx.beginPath() # 設定線的寬度為 1 個單位 if i == 0: ctx.lineWidth = 7 else: ctx.lineWidth = 1 ctx.moveTo(99, 100+i*30) ctx.lineTo(201, 100+i*30) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 垂直線 for i in range(6): ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 ctx.moveTo(100+i*20, 100) ctx.lineTo(100+i*20, 220) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() ctx.closePath() 至於將繪圖內容納入 def 函式定義格式後: from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"chord1\"] ctx = canvas.getContext(\"2d\") def background(x, y, xinc, yinc, xnum, ynum, ctx): # 水平線 for i in range(ynum+1): ctx.beginPath() # 設定線的寬度為 1 個單位 if i == 0: ctx.lineWidth = 7 else: ctx.lineWidth = 1 ctx.moveTo(x-1, y+i*yinc) ctx.lineTo(x+xnum*xinc+1, y+i*yinc) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 垂直線 for i in range(xnum+1): ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 ctx.moveTo(x+i*xinc, y) ctx.lineTo(x+i*xinc, y+ynum*yinc) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() ctx.closePath() background(300, 300, 10, 10, 5, 4, ctx) background(100, 300, 10, 10, 5, 4, ctx) background(300, 100, 10, 10, 5, 12, ctx) 之後進一步將 background 與 ball 配合進行函式設計後: def background(x, y, xinc, yinc, xnum, ynum, ctx): # 水平線 for i in range(ynum+1): ctx.beginPath() # 設定線的寬度為 1 個單位 if i == 0: ctx.lineWidth = 7 else: ctx.lineWidth = 1 ctx.moveTo(x-1, y+i*yinc) ctx.lineTo(x+xnum*xinc+1, y+i*yinc) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 垂直線 for i in range(xnum+1): ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 ctx.moveTo(x+i*xinc, y) ctx.lineTo(x+i*xinc, y+ynum*yinc) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() ctx.closePath() # 一開始 x, y 為圓球圓心, 但是為了配合和弦繪圖 # 將 x, y 改為和弦的左上角座標 x, y # 配合 w, h, wcoord, hcoord 進行運算得到圓的圓心座標 bx, by # r 最後配合 w 與 h 較小的值進行運算 def ball(x, y, w, h , wcoord, hcoord, color, ctx): bx = x + (wcoord-1)*w by = y + (hcoord-1)*h+h/2 if w < h: r2 = w/2 -2 else: r2 = h/2 -2 ctx.beginPath() ctx.fillStyle = color ctx.strokeStyle = color ctx.arc(bx, by, r2, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() # 利用 x, y 定義和弦左上角座標, 放入的圓也必須配合此一座標運算 x = 300 y = 200 w = 20 h = 30 background(x, y, w, h, 5, 4, ctx) for i in range( 6): for j in range(3): ball(x, y, w, h, i+1, j+1, 'black', ctx) ball(x, y, w, h, 1, 4, 'red', ctx) 註記: 其實使用 html5 CANVAS , 以 png 格式繪製吉他和弦圖, 只是為了讓 Python3 的初學者熟悉變數、數列、迴圈、函式與類別的基本計算機程式語法. 就實用上, 應該要使用 Python3 程式建立 SVG 向量圖. http://www.joebrown.org.uk/wp/?p=8553 就是採用 Python2 與 MySQL 資料庫建立大量的吉他和絃 SVG 圖, 將這個程式改為 Python3 並且配合網際應用 (Flask), 建立一套可以利用程式方法建立各式歌曲的吉他和絃譜, 並且結合 MIDI 或機械手彈奏, 應該是一系列不錯的專題應用.","tags":"Course"},{"title":"2016Fall 機械設計主題教學 (cpa)","url":"./2016fall-ji-jie-she-ji-zhu-ti-jiao-xue-cpa.html","text":"知識管理與最佳化應用實驗室試圖利用計算機程式、網際內容管理、電腦輔助設計實習與協同產品設計實習等課程, 進行與機械設計相關的主題式教學, 其中包含強化創造力的教學、令學員熟習六種工程表達方式, 並且俱備融入協同設計所需要的四大面向知識與技能. 機械設計主題教學 創造力三元素, 機械設計的六種表達, 協同設計的四大面向. 強化創造能力 - 自學力、程式力與想像力 (Creative Competencies) 熟習六種表達 - 口語、文字、2D、3D、理論與實體表達 (Six Presentation Methods) 融入協同設計 - 電腦、網路、軟硬體工具與協同專案 (Collaborative Designs)","tags":"Misc"}]};